import sys
import subprocess
import os
import pefile
import hashlib
import array
import math
import csv


def get_resources(pe):
    """Extract resources :
    [entropy, size]"""
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources

def get_version_info(pe):
    """Return version infos"""
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
          res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
          res['os'] = pe.VS_FIXEDFILEINFO.FileOS
          res['type'] = pe.VS_FIXEDFILEINFO.FileType
          res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
          res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
          res['signature'] = pe.VS_FIXEDFILEINFO.Signature
          res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res

def extract_headers(name, path, report, result_path):
    sys.stdout.write("\r" + "[!] Extracting headers ...".ljust(50))
    sys.stdout.flush()

    pe = pefile.PE(path, fast_load=True)

    file_headers = []

    # from https://github.com/Te-k/malware-classification/blob/master/generatedata.py
    # https://www.randhome.io/blog/2016/07/16/machine-learning-for-malware-detection/
    #file_headers.append(name)
    #file_headers.append(get_md5(path))
    file_headers.append(pe.FILE_HEADER.Machine)
    file_headers.append(pe.FILE_HEADER.SizeOfOptionalHeader)
    file_headers.append(pe.FILE_HEADER.Characteristics)
    file_headers.append(pe.OPTIONAL_HEADER.MajorLinkerVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MinorLinkerVersion)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfCode)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfInitializedData)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfUninitializedData)
    file_headers.append(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
    file_headers.append(pe.OPTIONAL_HEADER.BaseOfCode)
    try:
        file_headers.append(pe.OPTIONAL_HEADER.BaseOfData)
    except AttributeError:
        file_headers.append(0)
    file_headers.append(pe.OPTIONAL_HEADER.ImageBase)
    file_headers.append(pe.OPTIONAL_HEADER.SectionAlignment)
    file_headers.append(pe.OPTIONAL_HEADER.FileAlignment)
    file_headers.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MajorImageVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MinorImageVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
    file_headers.append(pe.OPTIONAL_HEADER.MinorSubsystemVersion)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfImage)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfHeaders)
    file_headers.append(pe.OPTIONAL_HEADER.CheckSum)
    file_headers.append(pe.OPTIONAL_HEADER.Subsystem)
    file_headers.append(pe.OPTIONAL_HEADER.DllCharacteristics)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfStackReserve)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfStackCommit)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfHeapReserve)
    file_headers.append(pe.OPTIONAL_HEADER.SizeOfHeapCommit)
    file_headers.append(pe.OPTIONAL_HEADER.LoaderFlags)
    file_headers.append(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes)
    file_headers.append(len(pe.sections))
    entropy = list(map(lambda x: x.get_entropy(), pe.sections))
    file_headers.append(sum(entropy) / float(len(entropy)))
    file_headers.append(min(entropy))
    file_headers.append(max(entropy))
    raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
    file_headers.append(sum(raw_sizes) / float(len(raw_sizes)))
    file_headers.append(min(raw_sizes))
    file_headers.append(max(raw_sizes))
    virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
    file_headers.append(sum(virtual_sizes) / float(len(virtual_sizes)))
    file_headers.append(min(virtual_sizes))
    file_headers.append(max(virtual_sizes))
    # Imports
    try:
        file_headers.append(len(pe.DIRECTORY_ENTRY_IMPORT))
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        file_headers.append(len(imports))
        file_headers.append(len(filter(lambda x: x.name is None, imports)))
    except AttributeError:
        file_headers.append(0)
        file_headers.append(0)
        file_headers.append(0)
    # Exports
    try:
        file_headers.append(len(pe.DIRECTORY_ENTRY_EXPORT.symbols))
    except AttributeError:
        # No export
        file_headers.append(0)
    # Resources
    resources = get_resources(pe)
    file_headers.append(len(resources))
    if len(resources) > 0:
        entropy = map(lambda x: x[0], resources)
        file_headers.append(sum(entropy) / float(len(entropy)))
        file_headers.append(min(entropy))
        file_headers.append(max(entropy))
        sizes = map(lambda x: x[1], resources)
        file_headers.append(sum(sizes) / float(len(sizes)))
        file_headers.append(min(sizes))
        file_headers.append(max(sizes))
    else:
        file_headers.append(0)
        file_headers.append(0)
        file_headers.append(0)
        file_headers.append(0)
        file_headers.append(0)
        file_headers.append(0)

    # Load configuration size
    try:
        file_headers.append(pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size)
    except AttributeError:
        file_headers.append(0)

    # Version configuration size
    try:
        version_infos = get_version_info(pe)
        file_headers.append(len(version_infos.keys()))
    except AttributeError:
        file_headers.append(0)

    result_csv = os.path.join(result_path, "header-" + name + ".csv")
    csv_writer = csv.writer(open(result_csv, 'w'), delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
    csv_writer.writerow(file_headers)


    sys.stdout.write("\r" + "[*] Headers extraction done.".ljust(50))
    sys.stdout.flush()

def extract_opcode(name, path, result_path):
    sys.stdout.write("\r" + "[!] Extracting opcode ...".ljust(50))
    sys.stdout.flush()

    process = subprocess.Popen("objdump -d " + path + " | sed  '/[^\t]*\t[^\t]*\t/!d' | cut -f 3 | sed 's/ .*$//' ", shell=True, stdout=subprocess.PIPE)
    (result, err) = process.communicate()

    result = result.decode('ASCII').replace('\n', ' ')
    print("res is:",result)
    result_path_txt = os.path.join(result_path, "opcode-" + name + ".txt")

    if not os.path.exists(result_path_txt):
        with open(result_path_txt, 'w+') as write_file:
            write_file.write(result)

    sys.stdout.write("\r" + "[*] Opcode extraction done.".ljust(50))
    sys.stdout.flush()

def extract_bytecode(name, path, result_path):
    sys.stdout.write("\r" + "[!] Extracting bytecode ...".ljust(50))
    sys.stdout.flush()

    result = ""
    with open(path, "rb") as read_file:
        hexdata = read_file.read().hex()
        hexlist = map(''.join, zip(*[iter(hexdata)] * 2))
    result = str(" ".join([str(int(x, 16)) for x in list(hexlist)]))

    result_path_txt = os.path.join(result_path, "bytecode-" + name + ".txt")

    if not os.path.exists(result_path_txt):
        with open(result_path_txt, 'w+') as write_file:
            write_file.write(result)

    sys.stdout.write("\r" + "[*] Bytecode extraction done.".ljust(50))
    sys.stdout.flush()
